
Resource Aware ML (RAML) is a tool that automatically and statically
computes resource-usage bounds for OCaml programs. For more
information refer to the RAML web site:

  http://www.cs.yale.edu/homes/hoffmann/raml

RAML is being developed by Jan Hoffmann and Shu-Chen Weng. It also
based on research results by Martin Hofmann, Steffen Jost, and others.


INSTALLATION
------------

Requirements:

  * OCaml compiler.  Version 4.01.0 and 4.02.0 are tested.
  * Findlib OCaml library manager:
    http://projects.camlcity.org/projects/findlib.html
  * Jane Street's Core (https://github.com/janestreet/core) and sexplib
    (https://github.com/janestreet/sexplib)
  * Coin-or Linear Programming (Clp) solver: https://projects.coin-or.org/Clp

  We recommand installing the first three via opam (https://opam.ocaml.org/):

    $ opam switch 4.02.0  # or 4.01.0 if current OCaml version is not supported
    $ opam install core sexplib  # Will pull in all necessary dependencies

Compiling:

  After installing all the requirements (Clp compiled, not necessarily
  installed system-wise), run the configure script with the path to Clp:

    $ ./configure --with-coin-clp /path/to/clp

  Where /path/to/clp should contain lib/ and include/ folder holding the
  library and header files, respectively.

  After configuration, simply run make to compile the main binary and unit
  tests.

    $ make -j 8

Clp note:

  If you chose not to install Clp to the system default location, you may have
  to set environment variables to allow loaders to find the dynamic library
  files:

    $ export LD_LIBRARY_PATH=/path/to/clp/lib

  or, on csh/tcsh:

    $ setenv LD_LIBRARY_PATH /path/to/clp/lib

  or, on MacOSX:

    $ export DYLD_LIBRARY_PATH=/path/to/clp/lib


UNIT TESTS
----------

A good way to test if the compilation was successful is the unit_test
binary that is included in the RAML distribution. For a given input
file, it computes bounds for the built-in metrics, evaluates the
program, and compares the resource bounds with the actual cost. 

The distribution comes with many unit tests. To execute them, run the
following in the top level directory of the distribution.

  $ make unit_tests.opt
  $ ./runtests

If everything compiled correctly then the call

   $ ./runtests

prints the following message at the end of its output.

    ------DONE-------
    All tests passed.
    -----------------


INPUT FILES
-----------

RAML inputs are in OCaml syntax. RAML uses Inria's OCaml parser and
type checker to ensure compatibility. An input file usually ends with
the extension '.raml'. The file should contain a list let bindings;
optionally followed by a main OCaml expression.  Examples can be found
in the following two directories

 ./tests    and    ./examples

There are still a lot of OCaml features that are currently not
supported, including:

- object-oriented language features
- modules
- complex inductive data types
- strings and characters
- nested patterns in pattern matches
- library functions (including the standard library)

We are working to shorten this list.


COMMAND LINE USAGE
------------------

For a description of the command-line usage options, run

  ./main usage    or    ./main.opt usage

The resource usage of input programs is defined by resource metrics
that assign a constant cost to each step in a big-step operational
semantics.  There are three built-in metrics:

- 'heap': number of allocated heap cells
- 'steps': number of evaluation steps
- 'ticks': executed tick commands

The tick metric allows the user to define a custom resource metric by
annotating the code with tick commands, such as

  Raml.tick(1.3)

The above command defines a resource usage of 1.3 resource units
whenever the expression is executed. The argument of Raml.tick is a
floating point number. A negative number expresses that resources are
returned. The result type of Raml.tick is unit.

RAML has two major modes of operation (actions): analysis and
evaluation.

1) Analysis (action analyze)

   The action 'analyze' performs the automatic resource bound
   analysis. It outputs the bounds in form of coefficients of resource
   polynomials and in a simplified form where the bound is described
   as a polynomial in the inputs.

   To analyze a program, the user has to specify a resource metric and
   a maximal degree of the bounds in the search space.

   Main Mode

   The standard analysis mode is the main mode. It computes a bound on
   resource cost of the evaluation of the last expression in the input
   (main expression). RAML assumes that the main expression has the
   form

     let _ = e       or       e

   RAML provides the option to print the resource-usage information of
   the functions that have been used in the main expression ('-print'
   flag). RAML prints one resource-annotated function type per
   function call. It is possible to print all of these annotated types
   ('-print all') or all annotated types that correspond to function
   calls up to a given depth in the syntax tree ('print level <lev>').

   Module Mode (flag -m)

   In the module mode, RAML infers a resource bound for every
   top-level function in the input file. For a function that has
   higher-order arguments, we assume that the resource cost of calling
   these functions is zero. The idea is, that the resulting bound
   describes the cost of the higher-order function itself.

2) Evaluation (action eval)

   The action 'eval' evaluates the last expression in the file (main
   expression). Again, RAML assumes that this expression is given in
   the form

     let _ = e       or       e

   RAML prints the result of the evaluation. It also measures and
   prints the resource cost as defined by the three built-in metrics
   'heap', 'steps', and 'ticks'.



